<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å„¿ç«¥è¯†å­—å¡ç‰‡ç”Ÿæˆå™¨ - å¤šåŠŸèƒ½ç‰ˆ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Balsamiq+Sans:wght@700&family=Comic+Neue:wght@700&family=Fredoka:wght@600&family=Itim&family=Patrick+Hand&family=Varela+Round&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #FF9AA2;
            --bg: #fdfdfd;
            --panel-bg: #ffffff;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }

        /* 0. å·¦ä¾§æ§åˆ¶é¢æ¿åŠ å®½ */
        .controls {
            width: 420px; /* åŠ å®½ä»¥å®¹çº³æ›´å¤šå†…å®¹ */
            background: var(--panel-bg);
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            border-right: 1px solid #eee;
            flex-shrink: 0;
        }

        h2 { margin: 0 0 5px 0; color: #444; font-size: 1.3rem; }
        .sub-title { font-size: 0.85rem; color: #888; margin-bottom: 10px; }
        
        .control-group {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        
        /* æ¯ä¸ªå•è¯çš„è¾“å…¥å— */
        .item-group {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            position: relative;
        }
        .item-label {
            font-size: 0.85rem; color: #888; font-weight: bold; margin-bottom: 5px;
            display: flex; justify-content: space-between;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.95rem;
            color: #555;
        }

        input[type="text"], select {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 0.95rem;
            transition: border 0.3s;
        }

        input[type="text"]:focus { border-color: var(--primary); outline: none; }

        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 5px;
            transition: all 0.2s;
            font-size: 0.95rem;
        }

        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn-secondary { background-color: #6c757d; font-size: 0.85rem; padding: 6px; }
        .btn-outline { background: transparent; border: 2px solid var(--primary); color: var(--primary); }

        .color-picker { display: flex; gap: 8px; flex-wrap: wrap; }
        .color-swatch {
            width: 30px; height: 30px; border-radius: 50%;
            cursor: pointer; border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.active { border-color: #555; transform: scale(1.15); }
        
        .icon-btn {
            width: 30px; height: 30px; border-radius: 50%;
            background: #eee; color: #555; display: flex; 
            align-items: center; justify-content: center;
            cursor: pointer; font-weight: bold; border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .icon-btn.active { border-color: #555; background: #ddd; }
        .random-btn { background: linear-gradient(135deg, #FF9AA2, #B5EAD7); color: white; border:none; }

        .custom-panel {
            background: #f8f9fa; padding: 12px; border-radius: 10px;
            margin-top: 10px; border: 1px solid #e9ecef;
        }
        .slider-row { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .slider-label { width: 15px; font-weight: bold; color: #666; font-size: 0.8rem; }
        .slider-val { width: 25px; font-size: 0.75rem; text-align: right; color: #666; }
        input[type=range] { flex: 1; accent-color: var(--primary); cursor: pointer; }

        .preview-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 20px 20px;
            padding: 30px;
            position: relative;
        }

        canvas {
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            border-radius: 20px;
            max-height: 95%;
            max-width: 95%;
            cursor: grab;
            background: white; 
        }
        canvas:active { cursor: grabbing; }

        .hint { font-size: 0.75rem; color: #999; margin-top: 3px; }

        .tabs { display: flex; gap: 5px; margin-top: 8px; background: #e9ecef; padding: 3px; border-radius: 6px; }
        .tab { flex: 1; padding: 5px; text-align: center; cursor: pointer; border-radius: 4px; font-size: 0.8rem; }
        .tab.active { background: white; color: var(--primary); font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }

        .hidden { display: none; }
        
        /* æ¨¡å¼åˆ‡æ¢å°æŒ‰é’® */
        .mode-switch { font-size: 0.8rem; cursor: pointer; color: var(--primary); text-decoration: underline; }
    </style>
</head>
<body>

    <div class="controls">
        <div>
            <h2>ğŸ¨ è¯†å­—å¡ç‰‡ç”Ÿæˆå™¨</h2>
            <div class="sub-title">å¤šåŠŸèƒ½ç‰ˆï¼šæ”¯æŒç»„åˆè¯å¡</div>
        </div>

        <!-- 1. å•è¯æ•°é‡é€‰æ‹© -->
        <div class="control-group">
            <label>1. å¡ç‰‡å¸ƒå±€ & å•è¯æ•°</label>
            <select id="itemCountSelect" onchange="handleCountChange()">
                <option value="1">å•å¼  (1ä¸ªå•è¯)</option>
                <option value="2">ä¸Šä¸‹åˆ†æ  (2ä¸ªå•è¯)</option>
                <option value="3">æ¨ªæ¡åˆ—è¡¨ (3ä¸ªå•è¯)</option>
                <option value="4">ç”°å­—æ ¼ (4ä¸ªå•è¯)</option>
            </select>
        </div>

        <!-- 2. åŠ¨æ€ç”Ÿæˆçš„è¾“å…¥æ¡†åŒºåŸŸ -->
        <div id="dynamicInputs">
            <!-- JS å°†åœ¨è¿™é‡Œç”Ÿæˆå†…å®¹ -->
        </div>

        <!-- 3. é…è‰²æ–¹æ¡ˆ -->
        <div class="control-group">
            <label>3. é…è‰²æ–¹æ¡ˆ</label>
            <div class="color-picker" id="colorPicker">
                <!-- é¢„è®¾é¢œè‰²ç”±JSç”Ÿæˆ -->
                <div class="icon-btn random-btn" onclick="randomizeColors()" title="éšæœºé…è‰²">ğŸ²</div>
                <div class="icon-btn" onclick="toggleCustomColor()" id="btnCustomColor" title="è‡ªå®šä¹‰é¢œè‰²">â•</div>
            </div>

            <div id="customColorPanel" class="hidden custom-panel">
                <label style="font-size: 0.85rem;">èƒŒæ™¯è‰² (RGB)</label>
                <div class="slider-row">
                    <span class="slider-label" style="color:#ff6b6b">R</span>
                    <input type="range" id="bgR" min="0" max="255" value="255" oninput="updateCustomColor()">
                    <span id="valR" class="slider-val">255</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label" style="color:#51cf66">G</span>
                    <input type="range" id="bgG" min="0" max="255" value="255" oninput="updateCustomColor()">
                    <span id="valG" class="slider-val">255</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label" style="color:#339af0">B</span>
                    <input type="range" id="bgB" min="0" max="255" value="255" oninput="updateCustomColor()">
                    <span id="valB" class="slider-val">255</span>
                </div>
                
                <div style="font-size:0.8rem; margin-top:8px; color:#666;">
                    *å¤šè¯æ¨¡å¼ä¸‹ï¼Œæ–‡å­—é¢œè‰²è‡ªåŠ¨æ ¹æ®ä½ç½®åˆ†é…æˆ–éšæœºç”Ÿæˆ
                </div>
            </div>
            
            <button class="btn btn-outline" style="margin-top:10px" onclick="generateNewTexture()">ğŸ”„ åˆ·æ–°èƒŒæ™¯çº¹ç†</button>
        </div>

        <!-- 4. å­—ä½“è®¾ç½® -->
        <div class="control-group">
            <label>4. å­—ä½“è®¾ç½®</label>
            <select id="fontSelect" onchange="updateCard()">
                <option value="'Fredoka', sans-serif">Fredoka (æ¨èï¼šåœ†æ¶¦å¯çˆ±)</option>
                <option value="'Balsamiq Sans', cursive">Balsamiq (æ‰‹å†™é£æ ¼)</option>
                <option value="'Patrick Hand', cursive">Patrick Hand (å„¿ç«¥æ‰‹å†™)</option>
                <option value="'Itim', cursive">Itim (ç«¥è¶£é£æ ¼)</option>
                <option value="'Comic Neue', cursive">Comic Neue (æ¼«ç”»é£æ ¼)</option>
                <option value="'Varela Round', sans-serif">Varela Round (ç®€æ´åœ†è§’)</option>
            </select>
        </div>

        <!-- 5. å¯¼å‡ºè®¾ç½® -->
        <div class="control-group" style="border:none;">
            <label>5. å¯¼å‡ºè®¾ç½®</label>
            <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#666;">
                <span>å° (600px)</span>
                <span id="widthVal" style="font-weight:bold; color:var(--primary)">1200px</span>
                <span>è¶…å¤§ (4000px)</span>
            </div>
            <input type="range" id="exportWidth" min="600" max="4000" value="1200" step="100" style="width:100%; margin-top:5px;" oninput="document.getElementById('widthVal').innerText = this.value + 'px'">
            <button class="btn" onclick="downloadCard()">ğŸ’¾ ä¿å­˜å¡ç‰‡åˆ°æœ¬åœ°</button>
        </div>
    </div>

    <div class="preview-area">
        <canvas id="cardCanvas"></canvas>
    </div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const canvas = document.getElementById('cardCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_WIDTH = 1000;
        const BASE_HEIGHT = 1500;
        
        // é¢„å®šä¹‰é¢œè‰²
        const colors = [
            { bg: '#FFDAC1', text: '#FF9AA2' }, { bg: '#E2F0CB', text: '#88D8B0' },
            { bg: '#B5EAD7', text: '#FF9AA2' }, { bg: '#C7CEEA', text: '#9facd8' },
            { bg: '#FFB7B2', text: '#FF6961' }, { bg: '#FFF5BA', text: '#F4D03F' },
            { bg: '#F0E68C', text: '#CD853F' }, { bg: '#E0FFFF', text: '#87CEEB' }
        ];
        
        // Emoji å­—å…¸
        const emojiMap = {
            'apple': 'ğŸ', 'banana': 'ğŸŒ', 'cat': 'ğŸ±', 'dog': 'ğŸ¶', 
            'sun': 'â˜€ï¸', 'moon': 'ğŸŒ™', 'star': 'â­', 'book': 'ğŸ“–', 
            'tree': 'ğŸŒ³', 'flower': 'ğŸŒ¸', 'fish': 'ğŸŸ', 'bird': 'ğŸ¦',
            'happy': 'ğŸ˜Š', 'sad': 'ğŸ˜¢', 'hot': 'ğŸ”¥', 'cold': 'â„ï¸',
            'big': 'ğŸ˜', 'small': 'ğŸœ', 'up': 'â¬†ï¸', 'down': 'â¬‡ï¸'
        };

        // --- å…¨å±€çŠ¶æ€ ---
        let state = {
            count: 1, // å•è¯æ•°é‡ 1-4
            items: [
                // åˆå§‹åŒ–4ä¸ªæ§½ä½ï¼Œé¿å…åˆ‡æ¢æ—¶æ•°æ®ä¸¢å¤±
                { word: "Apple", emoji: "ğŸ", mode: 'emoji', image: null, imgX: 0, imgY: 0, imgScale: 1 },
                { word: "Banana", emoji: "ğŸŒ", mode: 'emoji', image: null, imgX: 0, imgY: 0, imgScale: 1 },
                { word: "Cat", emoji: "ğŸ±", mode: 'emoji', image: null, imgX: 0, imgY: 0, imgScale: 1 },
                { word: "Dog", emoji: "ğŸ¶", mode: 'emoji', image: null, imgX: 0, imgY: 0, imgScale: 1 }
            ],
            colorIndex: 0, 
            bgRGB: [255, 218, 193], // é»˜è®¤èƒŒæ™¯
            textColors: ['#FF9AA2', '#FF9AA2', '#FF9AA2', '#FF9AA2'], // æ¯ä¸ªå•è¯çš„é¢œè‰²
            textureSeed: Math.floor(Math.random() * 1000000), 
            font: "'Fredoka', sans-serif"
        };

        function init() {
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            
            // åˆå§‹åŒ–é¢œè‰²é¢æ¿
            const picker = document.getElementById('colorPicker');
            const btnRandom = document.querySelector('.random-btn');
            colors.forEach((c, idx) => {
                const swatch = document.createElement('div');
                swatch.className = `color-swatch ${idx === 0 ? 'active' : ''}`;
                swatch.style.backgroundColor = c.bg;
                swatch.onclick = () => applyPresetColor(idx);
                picker.insertBefore(swatch, btnRandom);
            });

            // åˆå§‹ç”Ÿæˆè¾“å…¥æ¡†
            renderInputs();
            applyPresetColor(0); // åº”ç”¨é»˜è®¤è‰²
            
            document.fonts.ready.then(draw);
            setupCanvasInteractions();
            draw();
        }

        // --- åŠ¨æ€ç”Ÿæˆè¾“å…¥æ¡†é€»è¾‘ ---
        function handleCountChange() {
            state.count = parseInt(document.getElementById('itemCountSelect').value);
            renderInputs();
            draw();
        }

        function renderInputs() {
            const container = document.getElementById('dynamicInputs');
            container.innerHTML = ''; // æ¸…ç©º

            for (let i = 0; i < state.count; i++) {
                const item = state.items[i];
                const div = document.createElement('div');
                div.className = 'item-group';
                div.innerHTML = `
                    <div class="item-label">
                        <span>å•è¯ #${i+1}</span>
                        <div class="tabs" style="margin:0; font-size:0.7rem;">
                            <div class="tab ${item.mode === 'emoji' ? 'active' : ''}" onclick="switchItemMode(${i}, 'emoji')">Emoji</div>
                            <div class="tab ${item.mode === 'image' ? 'active' : ''}" onclick="switchItemMode(${i}, 'image')">å›¾ç‰‡</div>
                        </div>
                    </div>
                    <input type="text" value="${item.word}" placeholder="è¾“å…¥å•è¯" oninput="updateItemWord(${i}, this.value)" style="margin-bottom:5px;">
                    
                    <div id="emoji-ctrl-${i}" class="${item.mode !== 'emoji' ? 'hidden' : ''}" style="display:flex; gap:5px;">
                        <input type="text" value="${item.emoji}" oninput="updateItemEmoji(${i}, this.value)" style="width:50px; text-align:center;">
                        <button class="btn-secondary" onclick="searchEmoji(${i})">ğŸ” æœå›¾</button>
                    </div>

                    <div id="img-ctrl-${i}" class="${item.mode !== 'image' ? 'hidden' : ''}">
                        <input type="file" accept="image/*" onchange="uploadItemImage(${i}, this)" style="font-size:0.8rem;">
                        <button class="btn-secondary" style="margin-top:2px; width:auto;" onclick="resetImgPos(${i})">é‡ç½®ä½ç½®</button>
                    </div>
                `;
                container.appendChild(div);
            }
        }

        // --- æ•°æ®æ›´æ–°é€»è¾‘ ---
        function updateItemWord(index, val) {
            state.items[index].word = val;
            // è‡ªåŠ¨åŒ¹é…
            const lower = val.toLowerCase().trim();
            if (emojiMap[lower] && state.items[index].mode === 'emoji') {
                state.items[index].emoji = emojiMap[lower];
                // æ›´æ–°DOMæ˜¾ç¤º
                renderInputs(); // ç®€å•ç²—æš´é‡ç»˜è¾“å…¥åŒºä»¥æ›´æ–°emojiæ¡†çš„å€¼ï¼Œæˆ–è€…å•ç‹¬æ“ä½œDOM
                // ä¸ºäº†ä¸å¤±å»ç„¦ç‚¹ï¼Œæœ€å¥½åªæ›´æ–°å¯¹åº”inputï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼š
                document.querySelectorAll(`#emoji-ctrl-${index} input`)[0].value = emojiMap[lower];
            }
            draw();
        }

        function updateItemEmoji(index, val) {
            state.items[index].emoji = val;
            draw();
        }

        function switchItemMode(index, mode) {
            state.items[index].mode = mode;
            renderInputs(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–° active tab å’Œæ˜¾ç¤º/éšè—
            draw();
        }

        function searchEmoji(index) {
            window.open(`https://emojipedia.org/search/?q=${state.items[index].word}`, '_blank');
        }

        function uploadItemImage(index, input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        state.items[index].image = img;
                        resetImgPos(index);
                    }
                    img.src = e.target.result;
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        function resetImgPos(index) {
            if (!state.items[index].image) return;
            // è¿™é‡Œçš„é‡ç½®é€»è¾‘éœ€è¦çŸ¥é“è¯¥ item å ç”¨çš„åŒºåŸŸå¤§å°ï¼Œ
            // æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œå…ˆç®€å•é‡ç½®ä¸ºé»˜è®¤ï¼Œç»˜åˆ¶æ—¶è‡ªé€‚åº”
            state.items[index].imgScale = 1; 
            state.items[index].imgX = 0;
            state.items[index].imgY = 0;
            draw();
        }

        // --- é¢œè‰²å¤„ç† ---
        function hexToRgb(hex) {
            const bigint = parseInt(hex.substring(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function applyPresetColor(idx) {
            const c = colors[idx];
            state.colorIndex = idx;
            state.bgRGB = hexToRgb(c.bg);
            // æ‰€æœ‰å•è¯ç”¨åŒä¸€ä¸ªé¢„è®¾æ–‡å­—è‰²
            state.textColors = Array(4).fill(c.text);
            
            // æ›´æ–°UI
            document.getElementById('bgR').value = state.bgRGB[0];
            document.getElementById('bgG').value = state.bgRGB[1];
            document.getElementById('bgB').value = state.bgRGB[2];
            document.querySelectorAll('.color-swatch').forEach((el, i) => {
                if(i===idx) el.classList.add('active'); else el.classList.remove('active');
            });
            document.getElementById('btnCustomColor').classList.remove('active');
            document.getElementById('customColorPanel').classList.add('hidden');
            
            draw();
        }

        function toggleCustomColor() {
            document.getElementById('customColorPanel').classList.remove('hidden');
            document.getElementById('btnCustomColor').classList.add('active');
            document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active'));
            state.colorIndex = -1;
        }

        function updateCustomColor() {
            const r = parseInt(document.getElementById('bgR').value);
            const g = parseInt(document.getElementById('bgG').value);
            const b = parseInt(document.getElementById('bgB').value);
            state.bgRGB = [r, g, b];
            document.getElementById('valR').innerText = r;
            document.getElementById('valG').innerText = g;
            document.getElementById('valB').innerText = b;
            
            // å¦‚æœæ˜¯æ‰‹åŠ¨è°ƒèƒŒæ™¯ï¼Œæ–‡å­—é¢œè‰²å¦‚æœä¸æ”¹å¯èƒ½çœ‹ä¸æ¸…ï¼Œè¿™é‡Œæš‚ä¸è‡ªåŠ¨å˜
            if (state.colorIndex !== -1) {
                state.colorIndex = -1; // åˆ‡æ¢åˆ°è‡ªå®šä¹‰
            }
            draw();
        }

        function randomizeColors() {
            // èƒŒæ™¯ï¼šæµ…è‰²é©¬å¡é¾™
            const r = Math.floor(210 + Math.random() * 45);
            const g = Math.floor(210 + Math.random() * 45);
            const b = Math.floor(210 + Math.random() * 45);
            state.bgRGB = [r, g, b];
            
            // ä¸ºæ¯ä¸ªå•è¯ç”Ÿæˆä¸åŒçš„æ·±è‰²
            for(let i=0; i<4; i++) {
                // ç”Ÿæˆæ·±è‰²å¯¹æ¯”è‰²
                const tr = Math.floor(Math.random() * 150);
                const tg = Math.floor(Math.random() * 150);
                const tb = Math.floor(Math.random() * 150);
                state.textColors[i] = rgbToHex(tr, tg, tb);
            }

            // æ›´æ–°UI
            document.getElementById('bgR').value = r;
            document.getElementById('bgG').value = g;
            document.getElementById('bgB').value = b;
            toggleCustomColor();
            draw();
        }

        // --- æ ¸å¿ƒç»˜åˆ¶é€»è¾‘ (Layout Engine) ---
        function draw() {
            renderToContext(ctx, canvas.width, canvas.height);
        }

        function renderToContext(targetCtx, w, h) {
            const bgColor = `rgb(${state.bgRGB[0]}, ${state.bgRGB[1]}, ${state.bgRGB[2]})`;
            
            // 1. èƒŒæ™¯
            targetCtx.fillStyle = bgColor;
            targetCtx.fillRect(0, 0, w, h);

            // 2. çº¹ç† (ä½¿ç”¨ç¬¬ä¸€ä¸ªå•è¯çš„é¢œè‰²ä½œä¸ºçº¹ç†è‰²ï¼Œæˆ–è€…ç»Ÿä¸€æ·¡ç°è‰²)
            drawTexture(targetCtx, w, h, state.textColors[0]);

            // 3. å¸ƒå±€è®¡ç®—
            const count = state.count;
            let regions = []; // å­˜å‚¨ {x, y, w, h}

            if (count === 1) {
                regions.push({x: 0, y: 0, w: w, h: h});
            } else if (count === 2) {
                // ä¸Šä¸‹åˆ†
                regions.push({x: 0, y: 0, w: w, h: h/2});
                regions.push({x: 0, y: h/2, w: w, h: h/2});
                // åˆ†å‰²çº¿
                drawSeparator(targetCtx, 0, h/2, w, h/2);
            } else if (count === 3) {
                // ä¸‰è¡Œæ¨ªæ¡
                const h3 = h / 3;
                regions.push({x: 0, y: 0, w: w, h: h3});
                regions.push({x: 0, y: h3, w: w, h: h3});
                regions.push({x: 0, y: h3*2, w: w, h: h3});
                drawSeparator(targetCtx, 0, h3, w, h3);
                drawSeparator(targetCtx, 0, h3*2, w, h3*2);
            } else if (count === 4) {
                // ç”°å­—æ ¼
                const w2 = w/2, h2 = h/2;
                regions.push({x: 0, y: 0, w: w2, h: h2});
                regions.push({x: w2, y: 0, w: w2, h: h2});
                regions.push({x: 0, y: h2, w: w2, h: h2});
                regions.push({x: w2, y: h2, w: w2, h: h2});
                drawSeparator(targetCtx, 0, h2, w, h2); // æ¨ª
                drawSeparator(targetCtx, w2, 0, w2, h); // ç«–
            }

            // 4. ç»˜åˆ¶æ¯ä¸ªé¡¹ç›®
            regions.forEach((r, i) => {
                const item = state.items[i];
                const color = state.textColors[i];
                // 3ä¸ªå•è¯æ—¶ç‰¹æ®Šå¸ƒå±€ (å·¦å›¾å³å­—)
                const layoutType = (count === 3) ? 'horizontal' : 'vertical';
                drawItem(targetCtx, item, r.x, r.y, r.w, r.h, color, layoutType, i);
            });
        }

        function drawSeparator(ctx, x1, y1, x2, y2) {
            ctx.save();
            ctx.strokeStyle = "rgba(255,255,255,0.6)";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }

        function drawItem(ctx, item, x, y, w, h, color, layout, index) {
            ctx.save();
            // å‰ªè£åŒºåŸŸï¼Œé˜²æ­¢æº¢å‡º
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();

            // ç›¸å¯¹åæ ‡åŸºå‡†
            const cx = x + w/2;
            const cy = y + h/2;

            if (layout === 'horizontal') {
                // === æ¨ªå‘å¸ƒå±€ (å·¦å›¾å³å­—) ===
                const splitX = x + w * 0.35; // å›¾ç‰‡å å·¦è¾¹ 35%
                
                // 1. ç»˜åˆ¶å†…å®¹ (Emoji/Image) å·¦ä¾§å±…ä¸­
                const leftCx = x + (w * 0.35) / 2;
                const leftCy = cy;
                
                if (item.mode === 'emoji') {
                    const fontSize = Math.min(w * 0.2, h * 0.6);
                    ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.font = `${fontSize}px "Segoe UI Emoji"`;
                    ctx.fillText(item.emoji, leftCx, leftCy);
                } else if (item.image) {
                    drawImageInBox(ctx, item, leftCx, leftCy, w*0.3, h*0.8);
                }

                // 2. ç»˜åˆ¶æ–‡å­— å³ä¾§å±…ä¸­
                if (item.word) {
                    const rightCx = splitX + (w * 0.65) / 2;
                    // é™åˆ¶æ–‡å­—æœ€å¤§å®½åº¦
                    const maxTextW = w * 0.6; 
                    const maxTextH = h * 0.8;
                    drawAdaptiveText(ctx, item.word, rightCx, cy, maxTextW, maxTextH, color);
                }

            } else {
                // === çºµå‘å¸ƒå±€ (ä¸Šå›¾ä¸‹å­—) ===
                // å†…å®¹ä¸­å¿ƒç¨å¾®åä¸Š
                const contentCy = y + h * 0.45;
                const textCy = y + h * 0.82; 
                
                // 1. å†…å®¹
                if (item.mode === 'emoji') {
                    // å­—ä½“å¤§å°éšåŒºåŸŸå¤§å°å˜åŒ–
                    const fontSize = Math.min(w * 0.5, h * 0.45);
                    ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.font = `${fontSize}px "Segoe UI Emoji"`;
                    ctx.fillText(item.emoji, cx, contentCy);
                } else if (item.image) {
                    drawImageInBox(ctx, item, cx, contentCy, w*0.8, h*0.55);
                } else if (item.mode === 'image' && !item.image) {
                     ctx.fillStyle = 'rgba(0,0,0,0.1)';
                     ctx.font = `bold ${20}px Arial`;
                     ctx.textAlign = "center";
                     ctx.fillText("ä¸Šä¼ å›¾ç‰‡", cx, contentCy);
                }

                // 2. æ–‡å­—
                if (item.word) {
                    // æ–‡å­—ä½äºä¸‹æ–¹ï¼Œéœ€è‡ªé€‚åº”
                    const maxTextW = w * 0.9;
                    const maxTextH = h * 0.25; // ç•™ç»™æ–‡å­—çš„é«˜åº¦
                    // å¦‚æœæ˜¯4æ ¼ï¼Œæ–‡å­—ä½ç½®ç¨å¾®è°ƒæ•´
                    const tY = (state.count === 4) ? y + h * 0.85 : y + h * 0.82;
                    drawAdaptiveText(ctx, item.word, cx, tY, maxTextW, maxTextH, color);
                }
            }

            ctx.restore();
        }

// è¾…åŠ©ï¼šè‡ªé€‚åº”ç»˜åˆ¶æ–‡å­— (ä¿®å¤äº†å¯¼å‡ºæ—¶å­—ä½“è¿‡å°çš„é—®é¢˜)
        function drawAdaptiveText(ctx, text, x, y, maxW, maxH, color) {
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // --- ä¿®æ”¹å¼€å§‹ï¼šåŠ¨æ€åˆå§‹å­—å· ---
            // ä¹‹å‰æ˜¯å›ºå®š 180ï¼Œç°åœ¨ä»â€œæœ€å¤§å¯ç”¨é«˜åº¦â€å¼€å§‹å°è¯•
            // è¿™æ ·æ— è®ºæ˜¯é¢„è§ˆ(1000px)è¿˜æ˜¯å¯¼å‡º(4000px)ï¼Œéƒ½ä¼šè‡ªåŠ¨ç¼©æ”¾é€‚é…
            let fontSize = maxH; 
            // --- ä¿®æ”¹ç»“æŸ ---

            ctx.font = `900 ${fontSize}px ${state.font}`;
            let textMetrics = ctx.measureText(text);
            
            // å¾ªç¯ç¼©å°ç›´åˆ°é€‚é…å®½åº¦å’Œé«˜åº¦
            // å¢åŠ äº†æ­¥è¿›å€¼ (fontSize/20) ä»¥ä¾¿åœ¨å¤§åˆ†è¾¨ç‡ä¸‹è®¡ç®—æ›´å¿«
            while ((textMetrics.width > maxW || fontSize > maxH) && fontSize > 20) {
                fontSize -= Math.max(5, fontSize * 0.05); // åŠ¨æ€æ­¥è¿›ï¼Œå¤§å­—å·ç¼©å¾—å¿«
                ctx.font = `900 ${fontSize}px ${state.font}`;
                textMetrics = ctx.measureText(text);
            }

            // ç»˜åˆ¶æ•ˆæœ
            ctx.fillStyle = "rgba(0,0,0,0.15)";
            const shadowOffset = Math.max(2, fontSize * 0.04);
            ctx.fillText(text, x + shadowOffset, y + shadowOffset);

            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = Math.max(3, fontSize * 0.12);
            ctx.lineJoin = "round";
            ctx.miterLimit = 2;
            ctx.strokeText(text, x, y);

            ctx.strokeStyle = color;
            ctx.lineWidth = Math.max(1, fontSize * 0.02);
            ctx.strokeText(text, x, y);

            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
        }
        // è¾…åŠ©ï¼šç»˜åˆ¶å›¾ç‰‡ (æ”¯æŒæ‹–æ‹½ç¼©æ”¾)
        function drawImageInBox(ctx, item, cx, cy, maxW, maxH) {
            ctx.save();
            ctx.translate(cx, cy);
            
            // åŸºç¡€è‡ªé€‚åº”ç¼©æ”¾
            if (item.imgScale === 1 && item.imgX === 0) {
                 // å¦‚æœè¿˜æ²¡åŠ¨è¿‡ï¼Œè®¡ç®—ä¸€ä¸ªåˆå§‹ fit æ¯”ä¾‹
                 // è¿™é‡Œåªæ˜¯ç»˜åˆ¶æ—¶çš„ä¸´æ—¶è®¡ç®—ï¼Œä¸æ”¹å˜ state
            }
            
            // è®¡ç®—å›¾ç‰‡æ˜¾ç¤ºçš„åŸå§‹æ¯”ä¾‹
            const ratioW = maxW / item.image.width;
            const ratioH = maxH / item.image.height;
            const baseScale = Math.min(ratioW, ratioH);
            
            // å åŠ ç”¨æˆ·çš„ç¼©æ”¾å’Œä½ç§»
            ctx.scale(baseScale * item.imgScale, baseScale * item.imgScale);
            // ä½ç§»éœ€è¦åå‘é™¤ä»¥ scale å—ï¼Ÿ 
            // æˆ‘ä»¬çš„æ‹–æ‹½é€»è¾‘æ˜¯ç›´æ¥åŠ åƒç´ ï¼Œæ‰€ä»¥åœ¨ scale ä¹‹å‰ translate æ¯”è¾ƒç›´è§‚ï¼Œ
            // æˆ–è€…åœ¨ scale ä¹‹å translate (dx/scale)
            ctx.translate(item.imgX / baseScale / item.imgScale, item.imgY / baseScale / item.imgScale);

            ctx.drawImage(item.image, -item.image.width/2, -item.image.height/2);
            ctx.restore();
        }

// --- çº¹ç†ç»˜åˆ¶ (ä¼˜åŒ–ç‰ˆï¼šåŠ å¤§åŠ ç²—çš„æ—¥æœˆæ˜Ÿ) ---
        function drawTexture(ctx, w, h, color) {
            const ratio = w / BASE_WIDTH;
            const rng = new Math.seedrandom(state.textureSeed);
            
            const patternType = Math.floor(rng() * 8); 
            const baseSize = 50 + rng() * 40; 
            const size = baseSize * ratio;

            ctx.save();
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.15; 

            let cx, cy;

            if (patternType === 0) { // === åœ†ç‚¹ ===
                for (let x = 0; x < w; x += size) for (let y = 0; y < h; y += size) {
                    ctx.beginPath(); 
                    cx = x + ((Math.floor(y/size)%2) ? size/2 : 0);
                    ctx.arc(cx, y, size*0.15, 0, 6.28); 
                    ctx.fill();
                }
            } else if (patternType === 1) { // === æ–œçº¿ ===
                ctx.lineWidth = size * 0.12;
                for (let x = -h; x < w + h; x += size) { 
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x + h, h); ctx.stroke(); 
                }
            } else if (patternType === 2) { // === åå­— ===
                ctx.lineWidth = size*0.08; ctx.lineCap="round"; const cs=size*0.2;
                for(let x=0; x<w; x+=size) for(let y=0; y<h; y+=size){
                    cx=x+size/2; cy=y+size/2; ctx.beginPath();
                    ctx.moveTo(cx-cs,cy); ctx.lineTo(cx+cs,cy); 
                    ctx.moveTo(cx,cy-cs); ctx.lineTo(cx,cy+cs); ctx.stroke();
                }
            } else if (patternType === 3) { // === è™šçº¿æ–¹æ ¼ ===
                ctx.lineWidth = 2*ratio; ctx.setLineDash([6*ratio, 6*ratio]);
                for(let x=0; x<w; x+=size){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke();}
                for(let y=0; y<h; y+=size){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke();}
                ctx.setLineDash([]);
            } else {
                // === å½¢çŠ¶ç±»çº¹ç† (çˆ±å¿ƒ, æ˜Ÿæ˜Ÿ, æœˆäº®, å¤ªé˜³) ===
                // ç»Ÿä¸€åŠ ç²—çº¿æ¡ï¼Œè§£å†³â€œç¬”åˆ’è™šâ€çš„é—®é¢˜
                ctx.lineWidth = size * 0.08; 
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                for (let x = 0; x < w; x += size) {
                    for (let y = 0; y < h; y += size) {
                        cx = x + size/2; 
                        cy = y + size/2;
                        
                        // éšæœºåç§»
                        const offsetX = (rng() - 0.5) * size * 0.3;
                        const offsetY = (rng() - 0.5) * size * 0.3;
                        cx += offsetX; cy += offsetY;

                        ctx.save();
                        ctx.translate(cx, cy);

                        if (patternType === 4) { // === â¤ï¸ çˆ±å¿ƒ (å¡«å……) ===
                            const hs = size * 0.008; // ç¨å¾®åŠ å¤§
                            ctx.scale(hs, hs);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.bezierCurveTo(-50, -50, -100, 0, 0, 100);
                            ctx.bezierCurveTo(100, 0, 50, -50, 0, 0);
                            ctx.fill();
                        } else if (patternType === 5) { // === â­ äº”è§’æ˜Ÿ (åŠ å¤§) ===
                            const r = size * 0.35; // åŠå¾„ä»0.25å¢åŠ åˆ°0.35
                            ctx.beginPath();
                            for(let i=0; i<5; i++){
                                ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*r, 
                                           -Math.sin((18+i*72)/180*Math.PI)*r);
                                ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*r*0.4, 
                                           -Math.sin((54+i*72)/180*Math.PI)*r*0.4);
                            }
                            ctx.closePath();
                            ctx.stroke();
                        } else if (patternType === 6) {  // === ğŸŒ™ æ–°æœˆï¼ˆæœˆç‰™ï¼Œç˜¦ç‰ˆï¼‰ ===
							const rOuter = size * 0.42;      // å¤–åœ†åŠå¾„
							const rInner = rOuter * 0.75;   // å†…åœ†åŠå¾„ï¼ˆè¶Šå°è¶Šç˜¦ï¼‰
							const offsetX = rOuter * 0.35;  // å†…åœ†å‘å³åç§»ï¼ˆå†³å®šæœˆç‰™é”‹åˆ©ç¨‹åº¦ï¼‰

							ctx.save();
							ctx.rotate(-0.5); // å€¾æ–œè§’åº¦å¯ä¿ç•™

							ctx.beginPath();

							// 1. å¤–åœ†å¼§ï¼ˆC å½¢ï¼ŒèƒŒéƒ¨å‘å·¦ï¼‰
							ctx.arc(
							    0, 0,
							    rOuter,
							    0.3 * Math.PI,
							    1.7 * Math.PI,
							    false
							);

							// 2. å†…åœ†å¼§ï¼ˆåå‘ç”»ï¼Œç”¨æ¥â€œæŒ–â€ï¼‰
							ctx.arc(
							    offsetX, 0,
							    rInner,
							    1.7 * Math.PI,
							    0.3 * Math.PI,
							    true
							);

							ctx.closePath();
							ctx.stroke();
							ctx.restore();

                        } else if (patternType === 7) { // === â˜€ï¸ å¤ªé˜³ (åŠ å¤§) ===
                            const r = size * 0.18; // æ ¸å¿ƒåŠå¾„ä»0.12å¢åŠ åˆ°0.18
                            ctx.beginPath();
                            ctx.arc(0, 0, r, 0, 2 * Math.PI);
                            ctx.stroke();
                            // å…‰èŠ’
                            for(let i=0; i<8; i++) {
                                ctx.rotate(Math.PI / 4);
                                ctx.beginPath();
                                ctx.moveTo(r * 1.5, 0); // å…‰èŠ’èµ·ç‚¹å¤–ç§»
                                ctx.lineTo(r * 2.2, 0); // å…‰èŠ’é•¿åº¦å¢åŠ 
                                ctx.stroke();
                            }
                        }
                        ctx.restore();
                    }
                }
            }
            ctx.restore();
        }
        // --- äº¤äº’å¤„ç† (å¤šåŒºåŸŸæ‹–æ‹½) ---
        function updateCard() {
             state.font = document.getElementById('fontSelect').value;
             draw();
        }
        function generateNewTexture() { state.textureSeed = Math.floor(Math.random()*1e6); draw(); }

        function downloadCard() {
            const width = parseInt(document.getElementById('exportWidth').value);
            const height = width * 1.5;
            const offCanvas = document.createElement('canvas');
            offCanvas.width = width; offCanvas.height = height;
            const offCtx = offCanvas.getContext('2d');
            renderToContext(offCtx, width, height);
            const link = document.createElement('a');
            link.download = `Card-${state.items[0].word}-Combined.png`;
            link.href = offCanvas.toDataURL('image/png');
            link.click();
        }

        // å¤æ‚çš„æ‹–æ‹½é€»è¾‘ï¼šåˆ¤æ–­é¼ æ ‡åœ¨å“ªä¸ªåŒºåŸŸ
        function setupCanvasInteractions() {
            let isDragging = false;
            let activeIndex = -1;
            let lastX, lastY;

            function getRegionIndex(x, y) {
                const w = canvas.offsetWidth;
                const h = canvas.offsetHeight;
                // å°†æ˜¾ç¤ºåæ ‡è½¬æ¢ä¸ºç›¸å¯¹æ¯”ä¾‹ (0.0 - 1.0)
                const rx = x / w;
                const ry = y / h;
                
                if (state.count === 1) return 0;
                if (state.count === 2) return ry < 0.5 ? 0 : 1;
                if (state.count === 3) return ry < 0.33 ? 0 : (ry < 0.66 ? 1 : 2);
                if (state.count === 4) {
                    if (rx < 0.5 && ry < 0.5) return 0;
                    if (rx >= 0.5 && ry < 0.5) return 1;
                    if (rx < 0.5 && ry >= 0.5) return 2;
                    return 3;
                }
                return -1;
            }

            canvas.addEventListener('mousedown', (e) => {
                const idx = getRegionIndex(e.offsetX, e.offsetY);
                if (idx !== -1 && state.items[idx].mode === 'image') {
                    isDragging = true;
                    activeIndex = idx;
                    lastX = e.offsetX; lastY = e.offsetY;
                }
            });

            window.addEventListener('mouseup', () => { isDragging = false; activeIndex = -1; });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || activeIndex === -1) return;
                const dx = e.offsetX - lastX;
                const dy = e.offsetY - lastY;
                
                // å°†å±å¹•ä½ç§»è½¬æ¢ä¸º Canvas å†…éƒ¨ä½ç§»
                // è¿™é‡Œ canvas.width å¾ˆå¤§ï¼Œä½† CSS æ˜¾ç¤ºå¾ˆå°
                const scale = canvas.width / canvas.offsetWidth;
                
                state.items[activeIndex].imgX += dx * scale;
                state.items[activeIndex].imgY += dy * scale;
                
                lastX = e.offsetX; lastY = e.offsetY;
                draw();
            });

            canvas.addEventListener('wheel', (e) => {
                const idx = getRegionIndex(e.offsetX, e.offsetY);
                if (idx !== -1 && state.items[idx].mode === 'image') {
                    e.preventDefault();
                    const zoomSpeed = 0.05;
                    if (e.deltaY < 0) state.items[idx].imgScale *= (1 + zoomSpeed);
                    else state.items[idx].imgScale *= (1 - zoomSpeed);
                    draw();
                }
            }, { passive: false });
        }

        Math.seedrandom = function(s) {
            s = Math.floor(s); var mask = 0xffffffff;
            var m_w = (123456789 + s) & mask; var m_z = (987654321 - s) & mask;
            return function() {
                m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
                m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;
                return (((m_z << 16) + (m_w & 65535)) >>> 0) / 4294967296;
            }
        }

        init();
    </script>
</body>
</html>